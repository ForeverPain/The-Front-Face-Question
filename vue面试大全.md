#                                                 vue面试大全



#### 0.什么是vue的生命周期？

>Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载等一系列过程，我们称这是Vue的生命周期。

#### 1.谈谈你对MVVM开发模式的理解

>Model：代表数据模型，数据和业务逻辑都在Model层定义
>
>View: 代表Ui视图，负责数据的展示
>
>ViewModel：负责监听Model中数据的改变且控制视图的更新，处理用户交互操作
>
>Model和View并无直接的关联，而是通过了ViewModel进行联系的，Model和ViewModel之间有着双向数据绑定的联系，因此，Model中的数据改变时会触发View层的刷新，View中由于交互操作而改变的数据也会在Model中同步
>
>这种模式实现了Model和View的数据自动同步，因此开发者只需要专注数据的维护操作即可，而不需要自己操作dom

#### 2.V-if和V-show有什么区别

>v-show仅仅控制元素的显示方式，将display属性在block和none来回切换，而v-if会控制这个dom节点的存在与否，当我们需要经常地切换某个元素的显示/隐藏时，会使用v-show会更加省性能上的开销，当需要一次显示或隐藏时，使用v-if 更加合理

#### 3.vue.js的两个核心是什么

>数据驱动和组件系统
>
>数据驱动： ViewModel，保证数据和视图的一致性
>
>组件系统：应用类UI可以看作全部是由组件树构成的

#### 4.vue的优点

>轻量级框架
>
>只关注视图层,是一个构建数据的视图集合,大小只有几十kb
>
>Vue.js通过简洁的API提供高效的数据绑定和灵活的组件系统
>
>视图,数据,结构分离:使数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作

#### 5.vue的生命周期

>1.beforeCreate
>
>（创建前） 在数据观测和初始化事件还未开始
>
>2.created
>
>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
>
>3.beforeMount
>
>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
>
>4.mounted
>
>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
>
>5.beforeUpdate
>
>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
>
>6.updated
>
>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
>
>7.beforeDestroy
>
>（销毁前） 在实例销毁之前调用。实例仍然完全可用。
>
>8.destroyed
>
>（销毁前） 在实例销毁之前调用。实例仍然完全可用。
>

#### 6.用于构建vue的vue-cli工程都用了那些技术，它们的作用分别是什么？

>1.vue.js: vue-cli工程的核心，主要特点是双向数据绑定和组件系统
>
>2.vue-router: vue官方推荐使用的路由框架
>
>3.vuex: 专为vue.js应用项目的状态管理器，主要用于维护vue组件间共用的一些变量和方法
>
>4.axios(fetch.ajax): 用于发起get或post等http请求，基于Promise设计
>
>6.eslint代码规范工具
>
>7.webpack: 模块加载和vue-cli工程打包器

#### 7.vue-cli 工程常用的 npm 命令有哪些？

>1. npm install：下载 node_modules 资源包的命令
>
>2. npm run dev： 启动 vue-cli 开发环境的 npm命令
>
>3. npm run build： vue-cli 生成 生产环境部署资源 的 npm命令
>
>4. npm run build--report： 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令

#### 8.谈一下vue-cli工程中每个文件夹和文件的用处？

>1.dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。
>
>2.node_modules：存放npm命令下载的开发环境和生产环境的依赖包。
>
>3.public：有的叫assets：存放项目中需要用到的资源文件，css、js、images以及index
>
>4.src文件夹：存放项目源码及需要引用的资源文件。
>
>5.src-api文件夹：放ajax相关操作的代码文件:index.js(相关的接口),ajax.js(封装的axios,拦截器)。有的叫 service：自己配置的vue请求后台接口方法。
>
>6.src-common文件夹：stylus的混合文件.styl，不要写到public也可以
>
>7.src-components文件夹：存放vue开发中抽离的一些公共组件。
>
>8.src-mock文件夹：mock数据存放文件及mock模拟接口（没有后台接口或接口不完整情况下可以模拟后台接口）
>
>9.src-pages文件夹：涉及到路由的组件
>
>10.src-router文件夹:vue-router，路由器及路由的配置
>
>11.src-store文件夹：存放 vue中的状态数据，用vuex集中管理
>
>12.App.vue文件：使用标签渲染整个工程的.vue组件。
>
>13.main.js文件：vue-cli工程的入口文件。
>
>14.package.json文件：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。

#### 9.vue常用的修饰符

>1.阻止冒泡：.stop
>
>2.阻止默认事件：.prevent
>
>3.添加事件侦听器时使用事件捕获模式 ：.capture
>
>4.只当事件在该元素本身（比如不是子元素）触发时触发回调：.self
>
>5.事件只触发一次：.once

#### 10.说一下vue的双向绑定数据的原理

>VUEvue 实现数据双向绑定主要是：采用数据劫持结合 “发布者 - 订阅者”模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、 getter，在数据变动时发布消息给订阅者，触发相应监听回调。

#### 11.vue的优点

>Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
>
>- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 `kb` ；
>- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
>- 双向数据绑定：保留了 `angular` 的特点，在数据操作方面更为简单；
>- 组件化：保留了 `react` 的优点，实现了 `html` 的封装和重用，在构建单页面应用方面有着独特的优势；
>- 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
>- 虚拟DOM：`dom` 操作是非常耗费性能的， 不再使用原生的 `dom` 操作节点，极大解放 `dom` 操作，但具体操作的还是 `dom` 不过是换了另一种方式；
>- 运行速度更快：相比较于 `react` 而言，同样是操作虚拟 `dom` ，就性能而言， `vue` 存在很大的优势。

#### 12.vue父组件向子组件传递数据？

>通过 props

#### 13.子组件像父组件传递事件？

>`$emit` 方法

#### 14.为什么使用key

>需要使用 `key`来给每个节点做一个唯一标识， `Diff` 算法就可以正确的识别此节点。作用主要是为了高效的更新虚拟 DOM。

#### 15.v-show 和 v-if指令的共同点和不同点？

>**共同点：** 都能控制元素的显示和隐藏；
>
>**不同点：** 实现本质方法不同，`v-show` 本质就是通过控制 css 中的 `display` 设置为 `none`，控制隐藏，只会编译一次；`v-if` 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 `false` ，就不会编译了。而且 `v-if` 不停的销毁和创建比较消耗性能。总结：如果要频繁切换某节点，使用 `v-show` (切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用 `v-if`（初始渲染开销较小，切换开销比较大）。

#### 16.如何让CSS只在当前组件中起作用?

>在组件中的 `style` 前面加上 `scoped`

#### 17. keep-aliv的作用是什么?

>`keep-alive` 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

#### 18.解释单向数据流和双向数据绑定

>单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 `action` 来维护对应的 `state`
>
>双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 `debug` 的难度

#### 19. Vue 组件 data 为什么必须是函数

>因为js本身的特性带来的，如果 `data` 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 `data` 作为一个函数返回一个对象，那么每一个实例的 `data` 属性都是独立的，不会相互影响了

#### 20.对比 jQuery ，Vue 有什么不同

>jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发

#### 21.如何让CSS只在当前组件中起作用

>在组件中的style前面加上scoped就可以了

#### 22.第一次页面加载会触发哪几个钩子？

>会触发 下面这几个beforeCreate, created, beforeMount, mounted 。

#### 23.简述vue每个周期具体适合哪些场景

>beforecreate : 可以在这加个loading事件，在加载实例时触发
>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
>mounted : 挂载元素，获取到DOM节点
>updated : 如果对数据统一处理，在这里写上相应函数
>beforeDestroy : 可以做一个确认停止事件的确认框
>nextTick : 更新数据后立即操作domx

#### 24.created和mounted的区别

>有改变dom的时候 就用mounted 没有改变dom操作就用created
>
>- created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图
>- mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

#### 25.Vue在哪个生命周期阶段调用异步请求最佳

>异步请求在哪个阶段都可以调用，因为会先执行完生命周期的钩子函数之后，才会执行异步函数，但如果考虑用户体验方面的话，在created中调用异步请求最佳，用户就越早感知页面的已加载，毕竟越早获取数据，在mounted实例挂载的时候就越及时。x

#### 26.vue-router 是什么?它有哪些组件

>路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是WebApp的链接路径管理系统。

#### 27.active-class 是哪个组件的属性？

>ctive-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换；

#### 28.怎么定义 vue-router 的动态路由? 怎么获取传过来的值

>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。

#### 29.vue-router有哪几种导航钩子（ 导航守卫 ）

> 1、全局守卫： `router.beforeEach`
>
> 2、全局解析守卫： `router.beforeResolve`
>
> 3、全局后置钩子： `router.afterEach`
>
> 4、路由独享的守卫： `beforeEnter`
>
> 5、组件内的守卫： `beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave`

#### 30.vue2.0中的$router 和 $route的区别

>router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。

#### 31.keep-alive的作用是什么?

>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

#### 32.如何获取dom?

>ref="domName" 用法：this.$refs.domName

#### 33.说出几种vue当中的指令和它的用法？

>v-model双向数据绑定；
>v-for循环；
>v-if v-show 显示与隐藏；
>v-on事件；v-once: 只绑定一次。

#### 34.v-modal的使用。

>v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
>v-bind绑定一个value属性；
>v-on指令给当前元素绑定input事件。

#### 35.请说出vue.cli项目中src目录每个文件夹和文件的用法？

>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置; app.vue是一个应用主组件；main.js是入口文件。

#### 36.vue常用的修饰符

>.stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡；
>.prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
>.capture：与事件冒泡的方向相反，事件捕获由外到内；
>.self：只会触发自己范围内的事件，不包含子元素；
>.once：只会触发一次。

#### 37.说说你对 SPA 单页面的理解，它的优缺点分别是什么？

>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
>**优点：**
>
>- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
>- 基于上面一点，SPA 相对对服务器压力小；
>- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
>
>**缺点：**
>
>- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
>- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
>- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

#### 38.Vue 组件间通信有哪几种方式？

>**（1）`props / $emit` 适用 父子组件通信**
>
>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。

#### 39.Vue 中是如何检测数组变化？

>`Vue`中检测数组变化核心有两点：
>
>- 首先，使用函数劫持的方式，重写了数组的方法
>- `Vue` 将 `data` 中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组 `api` 时，就可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次进行观测。

#### 40.Object.defineProperty缺点

>1.深度监听，需要递归到底，一次性计算量大
>2.无法监听新增属性/删除属性（vue2.0可以使用vue.set vue.delete)
>3.无法原生监听数组，需要特殊处理

#### 41.Proxy 的优势

>Proxy 可以直接监听对象而非属性
> Proxy 可以直接监听数组的变化
> Proxy 有多达 13 种拦截方法,不限于apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的
> Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改
> Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

#### 42.

#### 43.

#### 45.

#### 46.

#### 47.

#### 48.

#### 49.

#### 50.

#### 51.

#### 52.

#### 53.

#### 54.

#### 55.

#### 56.

#### 57.

#### 58.

#### 59.

#### 60.

#### 61.

#### 62.

#### 63.

#### 64.

#### 65.

#### 67.

#### 68.

#### 69.

#### 70.

#### 71.

#### 72.

#### 73.

#### 74.

#### 75.

#### 76.

#### 77.

#### 78.

#### 79.

#### 80.

#### 81.

#### 82.

#### 83.

#### 84.

#### 85.

#### 86.

#### 87.

#### 88.

#### 89.

#### 90.

#### 91.

#### 92.

#### 93.

#### 94.

#### 95.

#### 96.

#### 97.

#### 98.

#### 99.

#### 100.

.



